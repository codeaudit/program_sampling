pragma options "--slv-randassign --slv-ntimes 100000  --slv-randdegree  50 --bnd-unroll-amnt 16 --bnd-cbits 4";



struct str{    
    int n; char[n] ch;    
}

str cstr([int n] , char[n] ch){
    return new str(n=n, ch=ch);
}

// s = ...r1r2...
// returns  ^ position
// optionally skip over k occurrences
int Pos([int n1, int n2], str s, char[n1] r1, char[n2] r2, int k ){
    for(int i=0; i<s.n; ++i){
        if(i+ n1 + n2 < s.n){
            if(s.ch[i::n1]==r1 && s.ch[(i+n1)::n2] == r2){
                if(k==0){
                    return i+ n1;
                }else{
                    return Pos(cstr(s.ch[i+1:s.n]), r1, r2, k-1);
                }
            }
        }
    }   
}

str SubStr(str s, int p1, int p2){    
    return new str(n=p2-p1, ch=s.ch[p1:p2]);
}

str Concat(str s1, str s2){
    char[s1.n + s2.n] ch;
    ch[0::s1.n] = s1.ch;
    ch[s1.n::s2.n] = s2.ch;
    return cstr(ch);
}

generator str genExpr(str s){
  generator str term(){
    char[3] r1 = ??;
    char[3] r2 = ??;
    int r1l = ??(2);
    int r1l_p = ??(2);
    int r2l = ??(2);
    int r2l_p = ??(2);

    int p1_k = ??;
    int p2_k = ??;

    bit k1 = ??;
    bit k2 = ??;

    int p1_occurrence = ??;
    int p2_occurrence = ??;

    for (int j = 0; j < 3; j++) {
      if (j >= r1l && j >= r1l_p) assert r1[j] == '\0';
      if (j >= r2l && j >= r2l_p) assert r2[j] == '\0';
    }

    // produce all the holes that once
    if(??){
      //      assert r1l == 0;
      assert r1l_p == 0;
      assert r2l == 0;
      assert r2l_p == 0;

      assert p1_k == 0;
      assert p2_k == 0;

      assert k1 == 0;
      assert k2 == 0;

      assert p1_occurrence == 0;
      assert p2_occurrence == 0;

      return cstr(r1[0::r1l]); }
    else{
      int p1;
      if (k1) {
	assert r1l == 0;
	assert r2l == 0;
	assert p1_occurrence == 0;
	p1 = p1_k;
      } else {
	assert p1_k == 0;
	p1 = Pos(s, r1[0::r1l], r2[0::r2l], p1_occurrence);
      }

      int p2;
      if (k2) {
	assert r1l_p == 0;
	assert r2l_p == 0;
	assert p2_occurrence == 0;
	p2 = p2_k;
      } else {
	assert p2_k == 0;
	p2 = Pos(s, r1[0::r1l_p], r2[0::r2l_p], p2_occurrence);
      }
      
      return SubStr(s, p1, p2); 
    }
  }
    str out = Concat(term(),term());
    /*int i=0;
    minrepeat{
        out = Concat(out, term());
        assert i++ < 3;
	}*/
    return out;
}

str flashToy(str s){
    return genExpr(s);
}



bit eq(str s1, str s2){
    return s1.ch == s2.ch;    
}

/*
harness void main(){    
    assert eq(cstr("Singh"), flashToy(cstr("Rishabh Singh")) );    
}
*/


/*harness void main(){    
    assert eq(cstr("Tom"), flashToy(cstr("Tom and Jerry")) );    
    }*/

harness void main2() {
  assert eq(cstr("Tom"), flashToy(cstr("Tom and Jerry")) );    
    assert eq(cstr("Jack"), flashToy(cstr("Jack and Jill")) );
}


