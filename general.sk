#define BOUND 143
bit[BOUND] tape = ??;
int tape_index = 0;

#define O_EQ 0
#define O_LT 1
#define O_GT 2
struct Guard {
  int z;
  int o;
}


bit run_guard(Guard g, int z) {
  if (g.o == O_EQ) return g.z == z;
  if (g.o == O_LT) return g.z > z;
  return g.z < z;
}

bit flip() {
  bit b = tape[tape_index];
  tape_index++;
  return b;
}

int random_integer() {
  //  return ??;
  int r = 0;
  int f = 1;
  for (int p = 0; p <= 2; p++) {
    r = r + flip()*f;
    f = f*2;
  }
  return r;
}


struct Array{
  int s;
  int [s] A;
}

Array concatenate(Array a1,Array a2) {
  Array a = new Array(s = a1.s + a2.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  return a;
}

Array concatenate3(Array a1,Array a2,Array a3) {
  Array a = new Array(s = a1.s + a2.s + a3.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  a.A[(a2.s+a1.s) :: a3.s] = a3.A;
  return a;
}

Array cdr(Array a,ref bit success) {
  if (a.s == 0) {
    success = 0;
    return a;
  }
  success = 1;
  return new Array(s = a.s-1, A = a.A[1 :: (a.s-1)]);
}

Array filter(Guard g, Array a) {
  int outsz = 0;
  int [a.s] out;
  for (int i=0; i<a.s; ++i){
    if (run_guard(g,a.A[i])) {
      out[outsz++] = a.A[i];
    }
  }
  return new Array(s=outsz, A=out[0::outsz]);
}

Array singleton(int n) {
  return new Array(s = 1,A = {n});
}

int car(Array a,ref bit success) {
  success = 1;
  if (a.s > 0) return a.A[0];
  success = 0;
  return 0;
}

Array empty_list() {
  return new Array(s = 0,A = {});
}

Guard guard_expression(Array a,int d,ref bit success) {
  assert d > 1; // integer expression needs at least 1

  bit zs;
  int z = integer_expression(a,d-1,zs);
  success = zs;
  int o;
  bit c1 = flip();
  bit c2 = flip();

  if (c1) o = O_EQ;
  if (!c1 && c2) o = O_LT;
  if (!c1 && !c2) o = O_GT;

  return new Guard(z = z, o = o);
}

Array array_expression(Array a,int d,ref bit success) {
  assert d > 0;


  bit c1 = flip();
  if (d == 1) { // only terminals allowed
    success = 1;
    if (c1)
      return empty_list();
    else
      return a;
  }
  

  bit c2 = flip();

  bit array_success;
  Array lp = array_expression(a,d-1,array_success);
  bit integer_success;
  int z = integer_expression(a,d-1,integer_success);
  bit cdr_success;
  
  if (d > 2) {
    bit c3 = flip();
    bit guard_success;
    Guard g = guard_expression(a,d-1,guard_success);
    if (c1 && c2 && c3) { success = 1;  return empty_list(); }
    if (c1 && c2 && !c3) { success = 1; return a; }
    if (c1 && !c2 && c3) {
      if (array_success) {
	Array r = cdr(lp,cdr_success);
	success = cdr_success;
	return r;
      }
      success = 0;
      return lp;
    }
    if (c1 && !c2 && !c3) { success = integer_success; return singleton(z); }
    if (!c1 && c2 && c3) { success = guard_success && array_success; return filter(g,lp); }
  } else {
    if (c2 && c1) { success = 1; return empty_list(); }
    if (c2 && !c1) { success = 1; return a; }
    if (!c2 && c1) {
      if (array_success) {
	Array r = cdr(lp,cdr_success);
	success = cdr_success;
	return r;
      }
      success = 0;
      return lp;
    }
    if (!c2 && !c1) { success = integer_success; return singleton(z); }
  }

  assert 0;
}

int integer_expression(Array a,int d,ref bit success) {
  assert d > 0;
  if (d == 1) { success = 1; return 0; }
  bit integer_success;
  int zp = integer_expression(a,d-1,integer_success);
  bit array_success;
  Array l = array_expression(a,d-1,array_success);

  bit c1 = flip();
  bit c2 = flip();
  bit c3 = flip();

  if (c1&&c2) { success = 1; return 0; }
  if (c1&&!c2) { success = integer_success; return zp+1; }
  if (!c1&&c2) { success = integer_success; return zp-1; }
  if (c3) {
    if (array_success) {
      bit car_success;
      int r = car(l,car_success);
      success = car_success;
      return r;
    }
    success = 0;
    return 0;
  }
  success = array_success;
  return l.s;
}

Array recursive_expression(Array a, int bnd) {
  tape_index = 0;
  if (bnd < 1) return null;
  bit s1,s2,s3,s4,s5,s6;
  
  Guard g = guard_expression(a,3,s1);
  //  assert ?? == tape_index; // 6
  int target = integer_expression(a,3,s2);
  assert tape_index == 16; // 16
  Array b = array_expression(a,4,s3);
  //  assert tape_index == ??(10); // 47
  Array x = array_expression(a,4,s4); bit rx = flip();
  Array y = array_expression(a,4,s5); bit ry = flip();
  Array z = array_expression(a,4,s6); bit rz = flip();

  assert s1 && s2 && s3;
  if (run_guard(g,target)) return b;
  
  assert s4 && s5 && s6;

  //  if (rz || ry || rx) assert bnd > 0;
  if (rz) { assert x.s < a.s; x = recursive_expression(x, bnd-1); }
  if (ry) { assert y.s < a.s; y = recursive_expression(y, bnd-1); }
  if (rz) { assert z.s < a.s; z = recursive_expression(z, bnd-1); }

  

  return concatenate3(x,y,z);
}


Array specification(Array a) {
  if (a.s == 0) return empty_list();

  bit s;
  Guard g1 = new Guard(z = car(a,s), o = O_LT);
  Array x = filter(g1,a);
  Guard g2 = new Guard(z = car(a,s), o = O_GT);
  Array z = filter(g2,a);

  Array y = singleton(car(a,s));

  return concatenate3(x,y,z);
}


Array constant_array([int n],int [n] a) {
  return new Array(s = n,A = a);
}
void test_case([int n],int [n] a, int [n] b, int bnd) {
  Array o = recursive_expression(constant_array(a), bnd);
  assert o.s == n;
  assert o.A[0::n] == b;
}



/*
harness void l2() {
  test_case({1,2},{1,2});
  }*/
/*harness void l3() {
  test_case({4,5,3},{3,4,5},3);
}

harness void l4() {
  test_case({5,3,4},{3,4,5},3);
  }*/
harness void l5() {
  test_case({5,4,3},{3,4,5},3);
}

harness void l6() {
  test_case({1,3,2},{1,2,3},3);
}


