//pragma options "--bnd-unroll-amnt 3 --bnd-arr1d-size 3 --bnd-arr-size 3";

// Problem specification


//#define BOUND 64 // tape length

#define MAXIMUMNUMBER 7 // maximum number manipulated by program

bit[BOUND] tape = ??;
int tape_index = 0;
// guard length = 2, always
// array length = {?,1,6,15,33}
// integer l =    {?,0,4,13,31,67}


bit[EMBEDDINGLENGTH] auxiliary = ??;

#define O_EQ 0
#define O_LT 1
#define O_GT 2
struct Guard {
  int z;
  int o;
}

bit run_guard(Guard g, int z) {
  if (g.o == O_EQ) return z == g.z;
  if (g.o == O_LT) return z <= g.z;
  if (g.o == O_GT) return z >= g.z;
  assert 0;
}

bit flip() {
  bit b = tape[tape_index];
  tape_index++;
  return b;
}

int randomChoice() {
  bit b1 = flip();
  bit b2 = flip();
  bit b3 = flip();

  return 4*b1 + 2*b2 + 1*b3;
}

int validate_number(int x) {
  assert x >= 0 && x < (MAXIMUMNUMBER+1);
  return x;
}

struct Array{
  int s;
  int [s] A;
}

 
bit array_equal(Array a,Array b) {
  if (a.s != b.s) return 0;
  for (int j = 0; j < a.s; j++)
    if (a.A[j] != b.A[j]) return 0;
  return 1;
}


Array concatenate(Array a1,Array a2) {
  Array a = new Array(s = a1.s + a2.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  return a;
}


Array concatenate3(Array a1,Array a2,Array a3) {
  assert a1 != null;
  assert a2 != null;
  assert a3 != null;
  /*  assert a1.s + a2.s + a3.s >= 0;*/
  int l = validate_number(validate_number(a1.s) + validate_number(a2.s) + validate_number(a3.s));
  int[l] x;
  x[0 :: a1.s] = a1.A;
  x[a1.s :: a2.s] = a2.A;
  x[(a2.s+a1.s) :: a3.s] = a3.A;
  return new Array(s = l,A = x);
}

Array cdr(Array a,ref bit success) {
  if (a.s == 0) {
    success = 0;
    return a;
  }
  success = 1;
  return new Array(s = a.s-1, A = a.A[1 :: (a.s-1)]);
}

Array filter(Guard g, Array a) {
  int outsz = 0;
  int [a.s] out;
  for (int i=0; i<a.s; ++i){
    if (run_guard(g,a.A[i])) {
      out[outsz++] = a.A[i];
    }
  }
  return new Array(s=outsz, A=out[0::outsz]);
}

Array singleton(int n) {
  return new Array(s = 1,A = {n});
}

int car(Array a,ref bit success) {
  success = 1;
  if (a.s > 0) return a.A[0];
  success = 0;
  return 0;
}

Array empty_list() {
  return new Array(s = 0,A = {});
}

int guard_length(ref bit success) {
  success = 1;
  bit c1 = flip();
  bit c2 = flip();
  if (c1 && !c2) success = 0;
  return 2;
}

void force_zero_guard(int d) {
  int j = 0;
  repeat (2) {
    if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
    j++;
  } 
}

Guard guard_expression(int z,int d,ref bit success) {
  success = 1;

  bit c1 = flip();
  bit c2 = flip();
  int o = O_EQ; // do I need to set this?
  if (c1 && c2) o = O_EQ;
  if (c1 && !c2) success = 0;
  if (!c1 && c2) o = O_LT;
  if (!c1 && !c2) o = O_GT;
  
  return new Guard(z = z, o = o);
}

int array_length(int d, ref bit success) {
  success = 1;
  assert d > 0;
  bit c1 = flip();
  if (d == 1) return 1;

  bit c2 = flip();
  bit c3 = flip();
  int choice = 4*c1 + 2*c2 + 1*c3; //randomChoice();

  if (!((choice == 5) || (choice == 3))) {
    force_zero_array(d-1);
  }
  bit sa;
  int a = array_length(d-1,sa);

  if (!((choice == 4) || (choice == 3))) {
    force_zero_integer(d-1);
  }
  bit sz;
  int z = integer_length(d - 1,sz);

  if (!(choice == 3)) {
    force_zero_guard(d-1);
  }
  bit sg;
  int g = guard_length(sg);

  int mdl = 3;
  if (choice == 7 || choice == 6) return mdl;
  if (choice == 4) {
    success = sz;
    return mdl + z;
  }
  mdl += a;
  if (choice == 5) {
    success = sa;
    return mdl;
  }
  if (choice == 3) {
    mdl += (z + g);
    success = sa && sz && sg;
    return mdl;
  }
  success = 0;
  return 0;
}

void force_zero_array(int d) {
  assert d > 0;
  int j = 0;
  if (d == 1) {
    repeat (1) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else if (d == 2) {
    repeat (6) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else if (d == 3) {
    repeat (15) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else if (d == 4) {
    repeat (33) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else assert 0;
}

Array array_expression(Array a,int d,ref bit success,ref bit single,ref bit empty) {
  single = 0;
  empty = 0;
  
  assert d > 0;

  bit c1 = flip();
  if (d == 1) { // only terminals allowed
    success = 1;
    if (c1) {
      empty = 1;
      return empty_list();
    } else {
      return a;
    }
  }

  bit c2 = flip();
  bit c3 = flip();
  int choice = 4*c1 + 2*c2 + 1*c3; //randomChoice();

  bit array_success,array_single,array_empty;
  Array lp = array_expression(a,d-1,array_success,array_single,array_empty);
  
  
  bit integer_success,integer_increment,integer_decrement;
  int z = integer_expression(a,d-1,integer_success,integer_increment,integer_decrement);

  bit cdr_success;
  
  bit guard_success;
  Guard g = guard_expression(z,d-1,guard_success);
  
  if (choice == 7) {
    empty = 1;
    success = 1;
    return empty_list();
  }
  if (choice == 6) {
    success = 1;
    return a;
  }
  if (choice == 4) {
    single = 1;
    success = integer_success;
    return singleton(z);
  }
  
  
  if (choice == 5) {
    if (array_success) {
      Array r = cdr(lp,cdr_success);
      success = cdr_success && !array_single;
      return r;
    }
    success = 0;
    return empty_list();
  }
  
  if (choice == 3) {
    success = integer_success && array_success && guard_success && !array_empty;
    return filter(g,lp);
  }
  success = 0;
  return empty_list();
}

void force_zero_integer(int d) {
  assert d > 0;
  if (d == 1) return;

  int j = 0;
  if (d == 2) {
    repeat (4) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else if (d == 3) {
    repeat (13) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else if (d == 4) {
    repeat (31) {
      if (!ORIGINALAPPROACH) assert tape[tape_index + j] == 0;
      j++;
    }
  }
  else assert 0;
}

int integer_length(int d,ref bit success) {
  success = 1;
  assert d > 0;
  if (d == 1) return 0;

  int choice = randomChoice();

  if (!((choice == 6) || (choice == 5))) {
    force_zero_integer(d-1);
  }
  bit sz;
  int z = integer_length(d - 1,sz);

  if (!((choice == 4) || (choice == 3))) {
    force_zero_array(d-1);
  }
  bit sa;
  int a = array_length(d - 1,sa);

  if (choice == 7) return 3;
  if (choice == 6 || choice == 5) {
    success = sz;
    return 3 + z;
  }
  if (choice == 4 || choice == 3) {
    success = sa;
    return 3 + a;
  }
  success = 0;
  return 0;
}

int integer_expression(Array a,int d,ref bit success,ref bit incremented,ref bit decremented) {
  incremented = 0;
  decremented = 0;
  
  assert d > 0;
  if (d == 1) { success = 1; return 0; }

  int choice = randomChoice();
  
  bit integer_success,integer_incremented,integer_decremented;
  int zp = validate_number(integer_expression(a,d-1,integer_success,integer_incremented,integer_decremented));
  
  bit array_success,array_empty,array_single;
  Array l = array_expression(a,d-1,array_success,array_empty,array_single);


  if (choice == 7) { success = 1; return 0; }
  if (choice == 6) { success = integer_success && !integer_decremented; return validate_number(zp+1); }
  if (choice == 5) { success = integer_success && !integer_incremented; return validate_number(zp-1); }
  if (choice == 4) {
    if (array_success) {
      bit car_success;
      int r = validate_number(car(l,car_success));
      success = car_success && !array_single && !array_empty; 
      return r;
    }
    success = 0;
    return 0;
  }
  if (choice == 3) {
    success = array_success && !array_single && !array_empty;
    return validate_number(l.s);
  }
  success = 0;
  return 0;
}

int recursive_length() {
  tape_index = 0;
  int m = 3; // recursion options
  bit s0,s1,s2,s3,s4,s5,s6;
  m += integer_length(2,s0);
  m += guard_length(s1);
  m += integer_length(2,s2);
  m += array_length(2,s3);
  m += array_length(3,s4);
  flip();
  m += array_length(3,s5);
  flip();
  m += array_length(3,s6);
  flip();

  assert s0 && s1 && s2 && s3 && s4 && s5 && s6;

  return m;
}

Array recursive_expression(Array a, int bnd) {
  tape_index = 0;
  bit s0,s1,s2,s3,s4,s5,s6,ignore1,ignore2;

  int comparator = integer_expression(a,2,s0,ignore1,ignore2);
  Guard g = guard_expression(comparator,2,s1);
  int target = integer_expression(a,2,s2,ignore1,ignore2);
  Array b = array_expression(a,2,s3,ignore1,ignore2);
  
  assert s0 && s1 && s2 && s3;
  if (run_guard(g,target)) return b;

  if (bnd < 1) return null;

  Array x = array_expression(a,3,s4,ignore1,ignore2); bit rx = flip();
  Array y = array_expression(a,3,s5,ignore1,ignore2); bit ry = flip();
  Array z = array_expression(a,3,s6,ignore1,ignore2); bit rz = flip();

  assert s4 && s5 && s6;

  if (rx) {
    assert x.s < a.s;
    x = recursive_expression(x, bnd-1);
  }
  if (ry) {
    assert y.s < a.s;
    y = recursive_expression(y, bnd-1);
  }
  if (rz) {
    assert z.s < a.s;
    z = recursive_expression(z, bnd-1);
  }

  return concatenate3(x,y,z);
}

int counting_expression(Array a) {
  tape_index = 0;

  bit s0,ignore1,ignore2;

  int z = integer_expression(a,5,s0,ignore1,ignore2);
  assert s0;

  return z;
}

int counting_length() {
  tape_index = 0;
  bit s;
  int m = integer_length(5,s);
  assert s;
  return m;
}

Array constant_array([int n],int [n] a) {
  return new Array(s = n,A = a);
}

void counting_case([int n],int [n] a, int target) {
  Array k_a = constant_array(a);
  assert target == counting_expression(k_a);
}

void enforce_counting() {
  int mdl = counting_length();
  assert mdl > MINIMUMLENGTH-1;
  assert mdl < BOUND+1;
  int embedding_index = 0;
  repeat (EMBEDDINGLENGTH) {
    if (embedding_index < MINIMUMLENGTH || mdl > embedding_index) assert auxiliary[embedding_index];
    embedding_index++;
  }
}


void test_case([int n],int [n] a, int [n] b) {
  int bnd = n-1;
  
  Array k_a = constant_array(a);
  Array o = recursive_expression(k_a, bnd);  

  assert o.s == n;
  assert o.A[0::n] == b;
}



void enforce() {
  int mdl = recursive_length();
  assert mdl > MINIMUMLENGTH-1;
  assert mdl < BOUND+1;
  int embedding_index = 0;
  repeat (EMBEDDINGLENGTH) {
    if (embedding_index < MINIMUMLENGTH || mdl > embedding_index) assert auxiliary[embedding_index];
    embedding_index++;
  }
}
