pragma options "--bnd-unroll-amnt 3"; // --bnd-int-range 1";

#define BOUND 143
bit[BOUND] tape = ??;
int tape_index = 0;
int force_index = 0;

#define O_EQ 0
#define O_LT 1
#define O_GT 2
struct Guard {
  int z;
  int o;
}

bit run_guard(Guard g, int z) {
  if (g.o == O_EQ) return z == g.z;
  if (g.o == O_LT) return z <= g.z;
  if (g.o == O_GT) return z >= g.z;
  assert 0;
}

bit flip() {
  bit b = tape[tape_index];
  tape_index++;
  return b;
}

void force_zero(int n) {
  assert n < 5;
  
  int j = 0;
  repeat (5) {
    if (j < n) assert tape[force_index++] == 0;
    j++;
  }
}

struct Array{
  int s;
  int [s] A;
}

 
bit array_equal(Array a,Array b) {
  if (a.s != b.s) return 0;
  for (int j = 0; j < a.s; j++)
    if (a.A[j] != b.A[j]) return 0;
  return 1;
}


Array concatenate(Array a1,Array a2) {
  Array a = new Array(s = a1.s + a2.s,A = a1.A);
  a.A[a1.s :: a2.s] = a2.A;
  return a;
}

Array concatenate3(Array a1,Array a2,Array a3) {
  assert a1 != null;
  assert a2 != null;
  assert a3 != null;
  /*  assert a1.s + a2.s + a3.s >= 0;*/
  int[a1.s + a2.s + a3.s] x;
  x[0 :: a1.s] = a1.A;
  x[a1.s :: a2.s] = a2.A;
  x[(a2.s+a1.s) :: a3.s] = a3.A;
  return new Array(s = a1.s + a2.s + a3.s,A = x);
}

Array cdr(Array a,ref bit success) {
  if (a.s == 0) {
    success = 0;
    return a;
  }
  success = 1;
  return new Array(s = a.s-1, A = a.A[1 :: (a.s-1)]);
}

Array filter(Guard g, Array a) {
  int outsz = 0;
  int [a.s] out;
  for (int i=0; i<a.s; ++i){
    if (run_guard(g,a.A[i])) {
      out[outsz++] = a.A[i];
    }
  }
  return new Array(s=outsz, A=out[0::outsz]);
}

Array singleton(int n) {
  return new Array(s = 1,A = {n});
}

int car(Array a,ref bit success) {
  success = 1;
  if (a.s > 0) return a.A[0];
  success = 0;
  return 0;
}

Array empty_list() {
  return new Array(s = 0,A = {});
}

void force_zero_guard(int d) {
  assert d > 1;
  force_zero(2);
  force_zero_integer(d-1);
}

Guard guard_expression(Array a,int d,ref bit success,ref int mdl) {
  assert d > 1; // integer expression needs at least 1

  success = 1;

  bit ignore1,ignore2;

  bit c1 = flip();
  bit c2 = flip();
  int o = O_EQ; // do I need to set this?
  if (c1 && c2) o = O_EQ;
  if (c1 && !c2) success = 0;
  if (!c1 && c2) o = O_LT;
  if (!c1 && !c2) o = O_GT;

  
  bit zs;
  int z = integer_expression(a,d-1,zs,ignore1,ignore2,mdl);
  success = zs && success;

  mdl += 2; // choice of operator

  return new Guard(z = z, o = o);
}

void force_zero_array(int d) {
  assert d > 0;
  assert flip() == 0;
  if (d == 1) return;
  bit shallow = !(d > 2);

  if (shallow) force_zero(1);
  force_zero(2);

  force_zero_array(d-1);
  force_zero_integer(d-1);
  if (!shallow) force_zero_guard(d-1);
}

Array array_expression(Array a,int d,ref bit success,ref bit single,ref bit empty,ref int mdl) {
  single = 0;
  empty = 0;
  
  assert d > 0;

  bit shallow = !(d > 2);

  bit c1 = flip();
  if (d == 1) { // only terminals allowed
    mdl++;
    success = 1;
    if (c1) {
      empty = 1;
      return empty_list();
    } else {
      return a;
    }
  }
  

  bit c2 = flip();
  bit c3;
  if (!shallow) c3 = flip();

  bit array_success,array_single,array_empty;
  int array_mdl = 0;
  /*  if (!((shallow && !c1 && c2) || (!shallow && c1 && !c2 && c3) || (!shallow && !c1 && c2 && c3))) {
    force_index = tape_index;
    force_zero_array(d-1);
    }*/
  Array lp = array_expression(a,d-1,array_success,array_single,array_empty,array_mdl);
  
  
  bit integer_success,integer_increment,integer_decrement;
  int integer_mdl = 0;
  /*  if (!((shallow && !c1 && !c2) || (!shallow && c1 && !c2 && !c3))) {
    force_index = tape_index;
    force_zero_integer(d-1);
    }*/
  int z = integer_expression(a,d-1,integer_success,integer_increment,integer_decrement,integer_mdl);

  bit cdr_success;
  
  bit guard_success;
  int guard_mdl = 0;
  Guard g;
  if (!shallow) {
    /*    if (!(!c1 && c2 && c3)) {
      force_index = tape_index;
      force_zero_guard(d-1);
      }*/
    g = guard_expression(a,d-1,guard_success,guard_mdl);
  }

  // pay for the choice
  mdl += (shallow ? 2 : 3);

  if ((shallow && c1 && c2) || (!shallow && c1 && c2 && c3)) {
    empty = 1;
    success = 1;
    return empty_list();
  }
  if ((shallow && c1 && !c2) || (!shallow && c1 && c2 && !c3)) {
    success = 1;
    return a;
  }
  if ((shallow && !c1 && !c2) || (!shallow && c1 && !c2 && !c3)) {
    single = 1;
    mdl += integer_mdl;
    success = integer_success;
    return singleton(z);
  }
  mdl += array_mdl;
  if ((shallow && !c1 && c2) || (!shallow && c1 && !c2 && c3)) {
    //assert !array_single;
    //success = !array_single;
    if (array_success) {
      Array r = cdr(lp,cdr_success);
      success = cdr_success && !array_single;
      return r;
    }
    success = 0;
    return empty_list();
  }
  
  if (!shallow && !c1 && c2 && c3) {
    mdl += guard_mdl;
    //    assert !array_empty;
    success = array_success && guard_success && !array_empty;
    return filter(g,lp);
  }
  success = 0;
  return empty_list();
}

void force_zero_integer(int d) {
  assert d > 0;
  if (d == 1) return;

  force_zero(3);

  force_zero_integer(d-1);
  force_zero_array(d-1);
}


int integer_expression(Array a,int d,ref bit success,ref bit incremented,ref bit decremented,ref int mdl) {
  incremented = 0;
  decremented = 0;
  
  assert d > 0;
  if (d == 1) { success = 1; return 0; }

  bit c1 = flip();
  bit c2 = flip();
  bit c3 = flip();
  mdl += 3;

  bit integer_success,integer_incremented,integer_decremented;
  int integer_mdl = 0;
  /*  if (!((c1 && c2 && !c3) || (c1 && !c2 && c3))) {
    force_index = tape_index;
    force_zero_integer(d-1);
    }*/
  int zp = integer_expression(a,d-1,integer_success,integer_incremented,integer_decremented,integer_mdl);
  
  bit array_success,array_empty,array_single;
  int array_mdl = 0;
  /*  if (!((c1 && !c2 && !c3) || (!c1 && c2 && c3))) {
    force_index = tape_index;
    force_zero_array(d-1);
    }*/
  Array l = array_expression(a,d-1,array_success,array_empty,array_single,array_mdl);


  if (c1 && c2 && c3) { success = 1; return 0; }
  if (c1 && c2 && !c3) { mdl += integer_mdl; success = integer_success && !integer_decremented; return zp+1; }
  if (c1 && !c2 && c3) { mdl += integer_mdl; success = integer_success && !integer_incremented; return zp-1; }
  mdl += array_mdl;
  if (c1 && !c2 && !c3) {
    //assert !array_single && !array_empty;
    if (array_success) {
      bit car_success;
      int r = car(l,car_success);
      success = car_success && !array_single && !array_empty; 
      return r;
    }
    success = 0;
    return 0;
  }
  if (!c1 && c2 && c3) {
    //assert !array_single && !array_empty;
    success = array_success && !array_single && !array_empty;
    return l.s;
  }
  success = 0;
  return 0;
}

Array recursive_expression(Array a, int bnd, int mdl) {
  mdl = 0;
  
  tape_index = 0;
  bit s1,s2,s3,s4,s5,s6,ignore1,ignore2;
  
  Guard g = guard_expression(a,3,s1,mdl);
  int target = integer_expression(a,3,s2,ignore1,ignore2,mdl);
  Array b = array_expression(a,4,s3,ignore1,ignore2,mdl);

  assert s1 && s2 && s3;
  if (run_guard(g,target)) return b;

  if (bnd < 1) return null;

  Array x = array_expression(a,4,s4,ignore1,ignore2,mdl); bit rx = flip();
  Array y = array_expression(a,4,s5,ignore1,ignore2,mdl); bit ry = flip();
  Array z = array_expression(a,4,s6,ignore1,ignore2,mdl); bit rz = flip();
  


  
  //  assert tape_index == ??(10); // 47

  assert s4 && s5 && s6;

  //  if (rz || ry || rx) assert bnd > 0;
  if (rx) {
    assert x.s < a.s;
    int ignore_length = 0;
    x = recursive_expression(x, bnd-1,ignore_length);
  }
  if (ry) {
    assert y.s < a.s;
    int ignore_length = 0;
    y = recursive_expression(y, bnd-1,ignore_length);
  }
  if (rz) {
    assert z.s < a.s;
    int ignore_length = 0;
    z = recursive_expression(z, bnd-1,ignore_length);
  }

  return concatenate3(x,y,z);
}


Array specification(Array a,int bnd) {
  if (a.s == 0) return empty_list();
  if (bnd < 1) return null;

  bit s;
  Guard g1 = new Guard(z = car(a,s), o = O_LT);
  Array x = filter(g1,cdr(a,s));
  Guard g2 = new Guard(z = car(a,s), o = O_GT);
  Array z = filter(g2,cdr(a,s));

  Array y = singleton(car(a,s));

  x = specification(x,bnd-1);
  z = specification(z,bnd-1);

  return concatenate3(x,y,z);
}


Array constant_array([int n],int [n] a) {
  return new Array(s = n,A = a);
}
void test_case([int n],int [n] a, int [n] b, int bnd) {
  int mdl = 0;
  Array k_a = constant_array(a);
  Array o = recursive_expression(k_a, bnd,mdl);

  assert o.s == n;
  assert o.A[0::n] == b;
}

harness void main(){
  test_case({5,4,3},{3,4,5},3);
  // test_case({1,3,2},{1,2,3},3);
  //test_case({4,5},{4,5},2);
  /*  test_case({6,1},{1,6},2);
  test_case({5},{5},1);
  test_case({},{},0); */
}
  

/*
harness void l5() {
  test_case({5,4,3},{3,4,5},3);
}

harness void l6() {
  test_case({1,3,2},{1,2,3},3);
}

harness void l2() {
    test_case({4,5},{4,5},2);
}

harness void l3() {
    test_case({6,1},{1,6},2);
}

harness void l1() {
  test_case({8},{8},1);
}

harness void l0() {
  test_case({},{},1);
}
  

*/
